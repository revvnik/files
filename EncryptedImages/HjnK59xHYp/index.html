<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"
            integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://files.revvnik.com/assets/css/style.css" rel="stylesheet">
    <link href="https://files.revvnik.com/node_modules/lightbox2/src/css/lightbox.css" rel="stylesheet" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>


    <!--REPLACE WITH https://files.revvnik.com/-->
    <title>Revvnik - Files</title>
</head>

<body>

    <div class="container header">
        <p id="headerText">Download your photos!</p>
        <img id="headerImage" src="../assets/camera.png">
    </div>

    <div class="container hint">
        <p id="hintText">
            By clicking on the below button, you will receive a popup prompting for the decryption key. This is a
            security measure.
        </p>
        <div class="hintButtons">
            <button class="startDecryption" onclick="promptForKey();">&nbsp;&nbsp;Enter key&nbsp;&nbsp;</button>
        </div>
    </div>

    <div class="space1"></div>

    <div id="image-grid" class="image-grid">
        <!-- Decrypted images will appear here -->
    </div>

    <div class="container space1"></div>
    <div class="container space1"></div>

    <div class="wrapper" id="wrapper">
        <div class="footer" id="footer">
            <div class="paypal" style="display: flex; flex-direction: row;">
                <!--<p style="margin: 0;">IF YOU LIKE MY WORK, YOU CAN SUPPORT ME ON&nbsp;&nbsp;</p>-->

            </div>

            <p style="margin: 0;">FOR CONTACT,&nbsp;&nbsp;PLEASE EMAIL ME AT&nbsp;&nbsp;</p>
            <p style="opacity: 100%;">
                <a href="mailto:revvnik@gmail.com" style="text-decoration: none;">revvnik@gmail.com</a><br>
            </p>
            <p>
                <a href="https://paypal.me/nik.sttr" style="text-decoration: none;">
                    SUPPORT ME <i class="bi bi-paypal"></i> nik.sttr
                </a>
            </p>
            <p>REVVNIK © 2021-2025 ALL RIGHTS RESERVED</p>
        </div>
    </div>
    <script>
        async function promptForKey() {
            const hexKey = prompt('Please enter the decryption key:');
            if (hexKey) {
                const { albumName, albumFiles, watermarkedFiles, instagramSizedFiles } = await loadEncryptedFiles();
                decryptAndDisplayImages(albumFiles, hexKey, albumName, watermarkedFiles, instagramSizedFiles);
            }
        }

        async function loadEncryptedFiles() {
            try {
                const response = await fetch('images.json');
                if (!response.ok) {
                    throw new Error('Failed to load JSON file');
                }
                const data = await response.json();

                const albumName = data.name;
                const albumFiles = data.noWatermarkFiles;
                const watermarkedFiles = data.watermarkedFiles;
                const instagramSizedFiles = data.instagramSizedFiles;

                return { albumName, albumFiles, watermarkedFiles, instagramSizedFiles };
            } catch (error) {
                alert(`Error loading files: ${error.message}`);
                return [];
            }
        }

        async function decryptAndDisplayImages(files, key, albumName, watermarkedFiles, instagramSizedFiles) {
            const imageGrid = document.getElementById('image-grid');
            imageGrid.innerHTML = ''; // Clear any existing images

            document.getElementById("wrapper").remove();

            const startDecryptionButton = $('.startDecryption'); // Get the "Enter key" button
            startDecryptionButton.prop('disabled', true);  // Disable it during decryption

            // Create promises for decryption
            const promises = files.map((file, index) => {
                const filePath = `encrypted/${file}`;
                return decryptFile(filePath, key)
                    .then(decryptedImageUrl => ({ index, url: decryptedImageUrl, fileName: file }))
                    .catch(error => {
                        console.error(`Failed to decrypt ${file}: ${error.message}`);
                        return { index, url: null }; // Mark failure for this image
                    });
            });

            const promisesWithWatermark = watermarkedFiles.map((file, index) => {
                const filePath = `encrypted-watermarked/${file}`;
                return decryptFile(filePath, key)
                    .then(decryptedImageUrl => ({ index, url: decryptedImageUrl, fileName: file }))
                    .catch(error => {
                        console.error(`Failed to decrypt ${file}: ${error.message}`);
                        return { index, url: null }; // Mark failure for this image
                    });
            });

            const promisesResized = instagramSizedFiles.map((file, index) => {
                const filePath = `encrypted-resized/${file}`;
                return decryptFile(filePath, key)
                    .then(decryptedImageUrl => ({ index, url: decryptedImageUrl, fileName: file }))
                    .catch(error => {
                        console.error(`Failed to decrypt ${file}: ${error.message}`);
                        return { index, url: null }; // Mark failure for this image
                    });
            });

            // Wait for all decryption to complete
            const decryptedImages = await Promise.all(promises);
            const decryptedWatermarkedImages = await Promise.all(promisesWithWatermark);
            const decryptedResizedImages = await Promise.all(promisesResized);

            // Filter out images that failed to decrypt
            const successfullyDecryptedImages = decryptedImages.filter(image => image.url !== null);
            const successfullyDecryptedWatermarkedImages = decryptedWatermarkedImages.filter(image => image.url !== null);
            const successfullyDecryptedResizedImages = decryptedResizedImages.filter(image => image.url !== null);

            // Load images into the grid
            const imageLoadPromises = successfullyDecryptedImages
                .sort((a, b) => a.index - b.index) // Ensure order by original index
                .map(({ url }) => {
                    return new Promise(resolve => {
                        const anchorElement = document.createElement('a');
                        anchorElement.href = url;
                        anchorElement.setAttribute('data-lightbox', 'gallery'); // Add lightbox attribute

                        const imgElement = document.createElement('img');
                        imgElement.src = url;
                        imgElement.alt = 'Decrypted Image';

                        imgElement.onload = resolve; // Resolve promise on image load
                        imgElement.onerror = resolve; // Also resolve on error to avoid blocking

                        anchorElement.appendChild(imgElement);
                        imageGrid.appendChild(anchorElement);
                    });
                });

            // Create promises for decrypting but not showing images
            const watermarkedImageDecryptionPromises = successfullyDecryptedWatermarkedImages
                .sort((a, b) => a.index - b.index) // Ensure order by original index
                .map(({ url }) => {
                    return new Promise(resolve => {
                        // Decrypting but no display or image loading
                        const image = new Image();
                        image.src = url;

                        // Resolve promise after the image is processed (but not displayed)
                        image.onload = resolve;
                        image.onerror = resolve; // Resolve on error to avoid blocking
                    });
                });

            const resizedImageDecryptionPromises = successfullyDecryptedResizedImages
                .sort((a, b) => a.index - b.index) // Ensure order by original index
                .map(({ url }) => {
                    return new Promise(resolve => {
                        // Decrypting but no display or image loading
                        const image = new Image();
                        image.src = url;

                        // Resolve promise after the image is processed (but not displayed)
                        image.onload = resolve;
                        image.onerror = resolve; // Resolve on error to avoid blocking
                    });
                });

            // Wait for all images to load
            await Promise.all(imageLoadPromises, watermarkedImageDecryptionPromises, resizedImageDecryptionPromises);

            // Generate ZIP
            const zip = new JSZip();
            const folder = zip.folder(albumName);
            const watermarkedFolder = zip.folder("Watermarked");
            const resizedFolder = zip.folder("Resized");

            // Add files to ZIP using async approach
            const filePromises = decryptedImages.map(async ({ fileName, url }) => {
                const response = await fetch(url);
                const blob = await response.blob();
                folder.file(fileName, blob);  // Add the file to the folder in the ZIP
            });

            const watermarkedFilePromises = decryptedWatermarkedImages.map(async ({ fileName, url }) => {
                const response = await fetch(url);
                const blob = await response.blob();
                watermarkedFolder.file(fileName, blob);  // Add the file to the folder in the ZIP
            });

            const resizedFilePromises = decryptedResizedImages.map(async ({ fileName, url }) => {
                const response = await fetch(url);
                const blob = await response.blob();
                resizedFolder.file(fileName, blob);  // Add the file to the folder in the ZIP
            });

            // Wait for all files to be added before generating the ZIP
            await Promise.all(filePromises, watermarkedFilePromises, resizedFilePromises);

            // Generate the ZIP file
            const zipBlob = await zip.generateAsync({ type: 'blob', compression: "DEFLATE", compressionOptions: { level: 6 } });
            const zipUrl = URL.createObjectURL(zipBlob);

            // Add Download All Button
            startDecryptionButton.replaceWith(`
                    <a id="downloadAllButton"
                        class="downloadAllButton btn btn-primary"
                        href="${zipUrl}"
                        download="${albumName.charAt(0).toUpperCase() + albumName.slice(1)}.zip"
                        style="background-color: #477DAC;">
                        Download ${decryptedImages.length} files
                    </a>
                `);

            $('#hintText').replaceWith('<p id="hintText"> Please wait while we prepare your file. Please also note that the file size may be bigger than expected, due to the file size of the images. Do not leave the page.</p>');
            $('#headerImage').hide();
            $('#headerText').replaceWith(`${albumName}`);
            $('<div class="wrapper" id="wrapper"><div class="footer" id="footer"><p style="margin: 0;">FOR CONTACT,&nbsp;&nbsp;PLEASE EMAIL ME AT&nbsp;&nbsp;</p><p style="opacity: 100%;"><a href="mailto:revvnik@gmail.com"style="text-decoration: none;">&nbsp;revvnik@gmail.com</a><br></p><p><a href="https://paypal.me/nik.sttr" style="text-decoration: none;">SUPPORT ME <i class="bi bi-paypal"></i> nik.sttr</a></p><p>REVVNIK © 2021-2025 ALL RIGHTS RESERVED</p></div></div>').appendTo($('body'));
        }



        async function decryptFile(filePath, hexKey) {
            const key = hexToBytes(hexKey);
            const iv = new Uint8Array(16); // Default IV of zeros

            // Validate key length
            if (key.length !== 16 && key.length !== 24 && key.length !== 32) {
                alert('Key length must be 16, 24, or 32 bytes.');
                return;
            }

            // Extract file extension from filePath
            const extension = filePath.slice(filePath.lastIndexOf('.')).toLowerCase();
            let mimeType;

            switch (extension) {
                case '.jpg':
                case '.jpeg':
                    mimeType = 'image/jpeg';
                    break;
                case '.png':
                    mimeType = 'image/png';
                    break;
                case '.gif':
                    mimeType = 'image/gif';
                    break;
                case '.webp':
                    mimeType = 'image/webp';
                    break;
                default:
                    mimeType = 'application/octet-stream'; // Default for unknown types
            }

            try {
                // Fetch the file as an ArrayBuffer
                const fileResponse = await fetch(filePath);
                const fileArrayBuffer = await fileResponse.arrayBuffer();

                // Import key
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'AES-CBC' },
                    false,
                    ['decrypt']
                );

                // Decrypt file
                const decryptedData = await crypto.subtle.decrypt(
                    { name: 'AES-CBC', iv: iv },
                    cryptoKey,
                    fileArrayBuffer
                );

                // Create a Blob for the decrypted data
                const decryptedBlob = new Blob([decryptedData], { type: mimeType });
                const url = URL.createObjectURL(decryptedBlob);

                // Return the URL for the decrypted file
                return url;
            } catch (error) {
                console.error('Error during decryption:', error);
                alert('Failed to decrypt the file.');
                return null;
            }
        }

        function hexToBytes(hex) {
            let bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substring(i, i + 2), 16));
            }
            return new Uint8Array(bytes);
        }


        /* async function zipAllFiles(albumName, albumFiles, decryptedUrls) {
                try {
                    const zip = new JSZip();
                    const folder = zip.folder(albumName);

                    for (let i = 0; i < albumFiles.length; i++) {
                        const fileName = albumFiles[i]; // Original filename from JSON
                        const imageUrl = decryptedUrls[i]; // Decrypted image URL

                        // Fetch the decrypted image blob
                        const response = await fetch(imageUrl);
                        const blob = await response.blob();

                        // Add the image to the zip with the original filename
                        folder.file(fileName, blob);
                    }

                    // Generate the ZIP file
                    const zipBlob = await zip.generateAsync({ type: 'blob' });

                    // Trigger the download
                    const zipUrl = URL.createObjectURL(zipBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = zipUrl;
                    downloadLink.download = `${albumName}.zip`;
                    downloadLink.click();
                } catch (error) {
                    console.error('Error during zip creation:', error);
                    alert('An error occurred while creating the ZIP file.');
                }
            } */



    </script>
    <script src="../node_modules/lightbox2/src/js/lightbox.js"></script>
</body>

</html>